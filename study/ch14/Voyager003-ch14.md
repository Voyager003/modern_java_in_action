## 모듈의 등장

소프트 웨어 아키텍처에서는 기반 코드를 변경할 때 유추하기 쉬우므로 생산성을 높일 수 있는 소프트웨어 프로젝트가 필요하다.

이 모듈 시스템은 어떤 문제를 해결할 수 있는가?

### 관심사 분리(SoC)

관심사 분리는 컴퓨터 프로그램을 고유의 기능으로 나누는 동작을 권장하는 원칙

예를 들어 회계 어플리케이션이 있다면 파싱, 분석, 레포트 기능을 모듈이란 각각의 부분으로 분리 가능

이로써 개별 기능을 따로 작업할 수 있으므로 
쉽게 협업 가능하며 전체 시스템을 쉽게 유지보수 가능하고, 정보를 은닉함으로써 세부 구현을 숨길 수 있음

이는 세부 구현을 숨김으로 프로그램의 어떤 부분을 변경했을 때 다른 부분에 미치는 영향을 줄일 수 있음

#### 한계점

Java는 클래스, 패키지, JAR 3가지 수준의 코드 그룹화를 제공

- class: 자바에서는 public, protected, private 등의 접근 제한자와 패키지 수준 접근 권한 등을 이용하여 메서드, 필드 클래스의 접근을 제어함
하지만 원하는 접근 제한을 달성하기가 어려우며, 최종 사용자에게 원하지 않은 메서드도 공개해야 하는 상황 발생

- 패키지와 JAR: 캡슐화를 거의 지원하지 않는다.
- 클래스 경로: 같은 클래스를 구분하는 버전 개념이 없으므로 2가지 버전의 같은 라이브러리가 존재할 경우 예측 불가
클래스 경로는 명시적인 의존성을 지원하지 않음 → 한 JAR이 다른 JAR에 포함된 클래스 집합을 사용하라고 명시적으로 의존성을 정의하는 기능을 제공하지 않음 (Maven, Gradle같은 빌드 도구로 해결)

Java는 클래스를 모두 컴파일한 다음 보통 한 개의 평범한 JAR 파일에 넣고 클래스 경로에 이 JAR 파일을 추가해 사용 가능 → JVM이 동적으로 클래스 경로에 정의된 클래스를 필요할 때 읽게됨

### 주요 구조: 모듈 declarations, requires, exports 

모듈은 module이라는 새 키워드에 이름과 바디를 추가해서 정의하고 
모듈 디스크립터는 module-info.java라는 특별한 파일에 저장함

- 모듈 디스크립터
각 모듈의 종속성, 특정 모듈이 다른 모듈들이 사용할 수 있도록 제공하는 패키지 등에 대한 구체적인 내용이 담긴 메타데이터

MAVEN 같은 도구를 사용할 때 모듈의 많은 세부사항을 IDE가 처리하며 사용자에는 잘 드러나지 않음

### 모듈화와 JDK 라이브러리
시스템을 모듈화할 때 모듈 크기를 결정해야 한다.

이 때, 모든 패키지가 자신의 모듈을 가진다.

거친 모듈화 기법 대부분은 한 모듈이 시스템의 모든 패키지를 포함

이는 이득에 비해 설계 비용이 증가하고, 모듈화의 모든 장점을 잃음

##### module-info.java

모듈 디스크립터로, 모듈의 소스 코드 파일 루트에 위치해야 한다

모듈의 의존성 그리고 어떤 기능을 외부로 노출할지를 정의

###### 동작방식

- 명령어 실행
> javac module-info.java com/exmaple/.../{Application.java} d target
>
> jar cvfe expenses-applicaion.jar com.example....{Applicaion} -C target

- 어떤 폴더와 클래스 파일이, 생성된 JAR에 포함되어있는지를 알려주는 결과 출력

> added manifest add module-info: module-info.class adding: com/(in = 0) (out = 0)(stored 0%) // 생략

- 생성된 JAR를 모듈화 애플리케이션으로 실행

> java --module-path expenses-applicaion.jar --module com.example....{Applicaion}

### 모듈과 메이븐 빌드
module expenses.readers {
requires java.base;

    exports com.example.expenses.readers;
    exports com.example.expenses.readers.file;
    exports com.example.expenses.readers.http;
}

#### exports 구문
exports는 다른 모듈에서 사용할 수 있도록 특정 패키지를 공개 형식 만듬

기본적으로 모듈 내의 모든 것은 캡슐화 된다.

#### requires 구문

'의존하고 있는 모듈'을 지정

기본적으로 모든 모듈은 java.base라는 플랫폼 모듈에 의존하는데, 이 java.base 외의 모듈을 import할 때 사용


### 기본적인 requires, exports 외의 모듈 지시어

#### 자동 모듈
특화 라이브러리를 사용하려고 하는 경우

module-info.java에 이 구문을 추가한다면 에러 발생
x
→ pom.xml도 갱신하여야 함

Java는 모듈 경로상에 있으나 module-info 파일을 가지지 않은 모든 JAR은 자동 모듈이 됨

자동 모듈은 암묵적으로 자신의 모든 패키지를 노출시킨다.

#### requires 구문
의존하고 있는 모듈을 지정한다.

컴파일 타임과 런타임에 한 모듈이 다른 모듈에 의존함을 정의한다.

기본적으로 모든 모듈은 java.base라는 플랫폼 모듈에 의존하는데, 이 java.base 외의 모듈을 import할 때 사용

#### exports 구문

exports는 다른 모듈에서 사용할 수 있도록 특정 패키지를 공개 형식으로 만듬

아무 패키지도 공개하지 않는 것이 기본 설정으로, 기본적으로 모듈 내의 모든 것은 캡슐화 된다.

### 모듈과 라이브러리의 차이점
라이브러리는 모듈과 비슷한(거의 같은) 개념이지만
모듈은 패키지 관리 기능까지 포함된 라이브러리이며, 일반 라이브러리는 내부에 포함된 모든 패키지에 외부 프로그램이 접근이 가능하지만, 
모듈은 다음과 같이 일부 패키지를 은닉하여 접근할 수 없게끔 할 수 있다.

또한 목적과 실행 시점이 다르다..
