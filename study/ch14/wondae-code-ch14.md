## 자바 모듈 시스템
### 14.1 압력 : 소프트웨어 유추
왜 자바의 모듈이 필요할까? 이번 장에선 소프트웨어 아키텍처 수준에서 추론하기 쉬운 소프트웨어를 만들기 위한 `관심사 분리`와 `정보 은닉`을 살펴본다
#### 14.1.1 관심사 분리
관심사 분리는 프로그램을 고유 기능으로 나누는 동작을 권장하는 원칙이다. 각각의 기능을 서로 겹치지 않느 코드 그룹으로 분리하는 것이다. 이를 통하여 애플리케이션의 클래스 사이의 관계를 시각적으로 보여줄 수 있다.

SoC(관심사 분리)는 모델, 뷰, 컨트롤러 같은 아키텍처 관점이나 복구 기법으로 비즈니스 로직과 분리하는 등의 하위 수준 접근 등의 상황에 유용하다. SoC는 다음과 같은 장점을 제공한다.
* 개별 기능의 따로 작업할 수 있으므로 쉽게 협업할 수 있다.
* 개별 부분으 재사용하기 쉽다.
* 전체 시스템을 쉽게 유지보수할 수 있다.

#### 14.1.2 정보 은닉
정보 은닉은 세부 구현을 숨기도록 장려한다. 세부 구현을 감춤으로서 프로그램의 변경이 다른 부분에 영향을 미칠 가능성을 줄일 수 있다. 정보 은닉을 위해선 캡슐화가 필요하다.

자바 9에선 클래스와 패킼지가 의도된 대로 공개되었는지 컴파일러로 확인할 수 있다.

#### 14.1.3 자바 소프트웨어
잘 설계된 소프트웨어를 위해선 위 두 원칙을 지켜야한다. 자바에선 원칙들을 위해 클래스와 인터페이스를 이용한다.

관심사 분리을 위해선 기능과 관련된 패키지, 클래스, 인터페이스를 그룹으로 만들어 코드를 그룹화한다. 그리고 코드 자체론 파악이 힘들 수 있기 때문에 UML 다이어그램을 이용하여 의존성을 시각적으로 파악할수 있다.

정보 은닉을 위해선 public, protected, private 접근자가 있다. 하지만 이 기능의 한계도 있는데, 이를 위해 14.2장에서 다룰 것이다.

### 14.2 자바 모듈 시스템을 설계한 이유
#### 14.2.1 모듈화의 한계
자바는 클래스, 패키지, JAR 수준의 코드 모듈화를 제공한다. 클래스에선 제한자와 캡슐화를 지원한다. 하지만 패키지와 JAR 수준에선 거의 지원하지 않는다.

**제한된 가시성 제어**

패키지 사이의 가시성은 어떻게 제어할까? 한 패키지의 클래스와 인터페이스를 외부에서 사용하려면 public으로 공개해야 한다. 하지만 이로 인하여 사용자는 내부적으로 사용하기 위한 구현을 마음대로 사용할 수 있다. 이는 코드의 결합성을 높이고, 코드의 노출 때문에, 보안 측면에서도 좋지 않다.

**클래스 경로**

자바는 클래스를 모두 컴파일 하여 JAR 파일로 만든 후 클래스 경로에 추가하여 사용할 수 있다. 이는 여러가지 약점이 있는데,
1. 클래스 경로에는 같은 클래스를 구분하는 버전 개념이 없다.
2. 명시적인 의존성을 지원하지 않는다.

이런 문제를 해결하기 위하여 maven이나 gradle 같은 빌드 도구를 사용할 수 있다. 그리고 자바 9의 모듈 시스템을 이용하면 컴파일 타임에 ClassNotFoundException과 같은 에러를 찾을 수 있다.

#### 14.2.2 거대한 JDK
JDK (자바 개발 키트)는 자바 프로그램을 만들고 실행하는데 도움을 주는 도구의 집합이다. 많은 세월이 지나면서 많은 기능이 추가되고 사장되었는데, 프로그램에 사용하지 않는 기능까지 추가되며 크기가 너무 거대해졌다.

자바 8에선 이런 문제를 해결하기 위해 컴팩트 프로파일이란 기법을 제시한다. 관련 분야에 따라 JDK를 3개로 나누었다. 하지만 이는 임시 대책일 뿐이다.

### 14.3 자바 모듈 : 큰 그림
자바 8에선 모듈이란 자바 프로그램의 구조 단위를 제공한다. 모듈은 module이란 새로운 키워드에 이름과 바디를 추가해서 정의한다. 모듈 디스크립터는 `module-info.java`라는 파일에 저장된다. 

모듈 디스크립터는 패키지와 같은 폴더에서 한개 이상의 패키지를 서술하고 캡슐화 하며, 단순한 상황에선 패키지 중 한 개만 외부로 노출시킨다.

### 14.4 자바 모듈 시스템으로 애플리케이션 개발하기.
간단한 모듈화 프로그램을 기초부터 만들면서 자바 9 모듈 시스템 전반을 살펴본다.
#### 14.4.1 애플리케이션 셋업
간단한 예시로 영수증 비용관리를 주제로 시작해보자. 애플리케이션이 해야할 일은 다음과 같다.
1. **파일 혹은 URL에서 비용 목록을 읽는다** : Reader 인터페이스 필요. 소스에 따라 HttpReader, FileReader 등 여러가지 구현 필요.
2. **비용의 문자열 표현을 파싱한다** : Json 객체를 도메인 객체로 재구성할 Parser
3. **통계를 계산한다** : 통계를 표현하기 위한 Expense 클래스
4. **유용한 요약 정보를 표시한다** : 요약할 SummaryCalculator 클래스
5. **각 작업의 시작, 마무리 지점을 표현한다** : ExpensesApplication

#### 14.4.2 세부적인 모듈화와 거친 모듈화
세부적인 모듈화는 모든 패키지가 자신의 모듈을 갖는다. 거친 모듈화는 한 모듈이 시스템의 모든 패키지를 포함한다. 각각의 장단점이 있는데, 세부적인 모듈화는 설계 비용이 커지며, 거친 모듈화는 모듈화의 장점을 잃는다. 가장 좋은 방법은 주기적으로 적절히 모듈화 되었는지 확인하는 것이다.

#### 14.4.3 자바 모듈 시스템 기초
모듈화 애플리케이션을 실행하기 위해선 아래와 같이 해야한다.
```bash
$javac module-info.java com/example/expenses/application/ExpensesApplication.java -d target

# 어떤 파일이 JAR에 포함되어 있는지 알려줌
$jar cvfe expenses-application.jar com.example.expenses.application.ExpensesApplication -C target

# 생성된 모듈화 어플리케이션 실행
$java --module-path expenses-application.jar --module expenses/com.example.expenses.application.ExpensesApplication
```

### 14.5 여러 모듈 활용하기
모듈을 이용한 애플리케이션을 바탕으로 다양한 모듈과 관련된 몇가지 예제를 살펴보자. 비용을 읽는 expense.reader라는 모듈을 만들고, exports와 requires를 이용해서 처리한다.

#### 14.5.1 exports 구문
```Java
module expenses.readers {
    exports com.example.expenses.readers;
    exports com.example.expenses.readers.file;
    exports com.example.expenses.readers.http;
}
```
exports는 다른 모듈에서 사용할 수 있도록 특정 패키지를 공개 형식으로 만든다. 모듈 시스템은 화이트리스트 기법으로 캡슐화를 제공하므로 무엇이 사용 가능한 기능인지 명시적으로 결정해야 한다.

#### 14.5.2 requires 구분
```Java
module expenses.readers {
    // 패키지가 아닌 모듈명
    requires java.base;
    
    // 모듈명이 아닌 패키지명
    exports com.example.expenses.readers;
    exports com.example.expenses.readers.file;
    exports com.example.expenses.readers.http;
}
```
requires는 의존하고 있는 모듈을 의미한다. 

#### 14.5.3 이름 정하기
모듈명은 인터넷 도메인을 역순으로 정하도록 권고한다.

ex) com.iteraterlearning.training

### 14.6 컴파일과 패키징
maven 혹은 gradle 같은 빌드 도구를 통해 프로젝트를 컴파일 할 수 있다.

### 14.7 자동 모듈
저수준 구현 대신 라이브러리를 사용해 구현한다면 어떻게 프로젝트에 추가할 수 있을까?

이를 위해선 module-info.java에 추가하는 대신 pom.xml 혹은 build.gradle에 dependency를 추가하여 처리할 수 있다.

### 14.8 모듈 정의와 구문들
exports와 requires 이외에 다른 구문들을 살펴본다.

1. requires transitive : 다른 모듈이 제공하는 공개 형식을 한 모듈에서 사용할 수 있다고 지정할 수 있다.
2. export to : 사용자에게 공개한 기능을 제한함으로 가시성을 더 정교하게 케어할 수 있다.
3. open, opens : 모든 패키지를 다른 모듈에 반사적으로 접근을 허용할 수 있다.
4. uses와 provides